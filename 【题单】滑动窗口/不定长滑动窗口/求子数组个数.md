# 713. 乘积小于 K 的子数组

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numSubarrayProductLessThanK = function (nums, k) {
  if (k <= 1) {
    return 0;
  }
  const n = nums.length;
  let prod = 1;
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    prod *= nums[right];
    while (prod >= k) {
      prod /= nums[left++];
    }
    ans += right - left + 1;
  }
  return ans;
};
```

# 1358. 包含所有三种字符的子字符串数目

```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfSubstrings = function (s) {
  const n = s.length;
  const cnt = {
    a: 0,
    b: 0,
    c: 0,
  };
  let ans = 0;
  for (let left = 0, right = -1; left < n; left++) {
    while (right < n && Object.values(cnt).some((i) => i < 1)) {
      right++;
      if (right === n) break;
      cnt[s[right]]++;
    }
    ans += n - right;
    cnt[s[left]]--;
  }
  return ans;
};
```

# 2962. 统计最大元素出现至少 K 次的子数组

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var countSubarrays = function (nums, k) {
  const n = nums.length;
  const max = Math.max(...nums);
  let cnt = 0;
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    if (nums[right] === max) {
      cnt++;
    }
    while (left < n && cnt >= k) {
      if (nums[left++] === max) {
        cnt--;
      }
    }
    ans += left;
  }
  return ans;
};
```

# 3258. 统计满足 K 约束的子字符串数量 I

```js
/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var countKConstraintSubstrings = function (s, k) {
  const n = s.length;
  const cnt = [0, 0];
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    cnt[s[right]]++;
    while (left <= right && cnt.every((i) => i > k)) {
      cnt[s[left++]]--;
    }
    ans += right - left + 1;
  }
  return ans;
};
```