# 3. 无重复字符的最长子串

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  const set = new Set();
  const n = s.length;
  if (n < 2) return n;
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    while (set.has(s[right])) {
      set.delete(s[left++]);
    }
    set.add(s[right]);
    ans = Math.max(ans, right - left + 1);
  }
  return ans;
};
```

# 3090. 每个字符最多出现两次的最长子字符串

```js
/**
 * @param {string} s
 * @return {number}
 */
var maximumLengthSubstring = function (s) {
  const n = s.length;
  const map = new Map();
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    while (map.get(s[right]) > 1) {
      map.set(s[left], map.get(s[left]) - 1);
      left++;
    }
    map.set(s[right], (map.get(s[right]) || 0) + 1);
    ans = Math.max(ans, right - left + 1);
  }
  return ans;
};
```

# 1493. 删掉一个元素以后全为 1 的最长子数组

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestSubarray = function (nums) {
  const n = nums.length;
  let sum = 0;
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    while (right - left - sum > 1) {
      sum -= nums[left];
      left++;
    }
    sum += nums[right];
    ans = Math.max(ans, sum);
  }
  return ans === n ? ans - 1 : ans;
};
```

# 1208. 尽可能使字符串相等

```js
/**
 * @param {string} s
 * @param {string} t
 * @param {number} maxCost
 * @return {number}
 */
var equalSubstring = function (s, t, maxCost) {
  const n = s.length;
  let sum = 0;
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    sum += Math.abs(s.charCodeAt(right) - t.charCodeAt(right));
    while (sum > maxCost) {
      sum -= Math.abs(s.charCodeAt(left) - t.charCodeAt(left));
      left++;
    }
    ans = Math.max(ans, right - left + 1);
  }
  return ans;
};
```

# 2730. 找到最长的半重复子字符串

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestSemiRepetitiveSubstring = function (s) {
  const n = s.length;
  let ans = 0;
  let cnt = 0;
  for (let left = 0, right = 0; right < n; right++) {
    if (s[right] === s[right - 1]) {
      cnt++;
    }
    while (cnt > 1) {
      if (s[left] === s[left + 1]) {
        cnt--;
      }
      left++;
    }
    ans = Math.max(ans, right - left + 1);
  }
  return ans;
};
```
