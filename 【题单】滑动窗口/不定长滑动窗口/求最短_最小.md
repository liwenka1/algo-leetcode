# 209. 长度最小的子数组

```js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
  const n = nums.length;
  let sum = 0;
  let ans = Infinity;
  for (let left = 0, right = 0; right < n; right++) {
    sum += nums[right];
    while (sum >= target) {
      ans = Math.min(ans, right - left + 1);
      sum -= nums[left++];
    }
  }
  return ans === Infinity ? 0 : ans;
};
```

# 2904. 最短且字典序最小的美丽子字符串

```js
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var shortestBeautifulSubstring = function (s, k) {
  const n = s.length;
  let ans = "";
  let cnt = 0;
  for (let left = 0, right = 0; right < n; right++) {
    if (s[right] === "1") {
      cnt++;
    }
    while (cnt > k || s[left] === "0") {
      if (s[left] === "1") {
        cnt--;
      }
      left++;
    }
    if (cnt === k) {
      const str = s.substring(left, right + 1);
      if (
        !ans ||
        ans.length > right - left + 1 ||
        (ans.length === str.length && ans > str)
      ) {
        ans = str;
      }
    }
  }
  return ans;
};
```

# 1234. 替换子串得到平衡字符串

```js
/**
 * @param {string} s
 * @return {number}
 */
var balancedString = function (s) {
  const cnt = {
    Q: 0,
    W: 0,
    E: 0,
    R: 0,
  };
  for (const str of s) {
    cnt[str]++;
  }
  const n = s.length;
  const m = n / 4;
  if (Object.values(cnt).every((i) => i === m)) {
    return 0;
  }
  let ans = n;
  for (let left = 0, right = 0; right < n; right++) {
    cnt[s[right]]--;
    while (Object.values(cnt).every((i) => i <= m)) {
      ans = Math.min(ans, right - left + 1);
      cnt[s[left++]]++;
    }
  }
  return ans;
};
```