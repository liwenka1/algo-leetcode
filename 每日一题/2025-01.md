# 3280. 将日期转换为二进制表示

```js
/**
 * @param {string} date
 * @return {string}
 */
var convertDateToBinary = function (date) {
  return date
    .split("-")
    .map((i) => Number(i).toString(2))
    .join("-");
};
```

# 729. 我的日程安排表 I

```js
var MyCalendar = function () {
  this.booked = [];
};

/**
 * @param {number} startTime
 * @param {number} endTime
 * @return {boolean}
 */
MyCalendar.prototype.book = function (startTime, endTime) {
  const n = this.booked.length;
  if (n === 0 || this.booked[n - 1][1] <= startTime) {
    this.booked.push([startTime, endTime]);
    return true;
  }
  const i = this.booked.findIndex((event) => event[0] >= endTime);
  if (i === 0 || (i > 0 && this.booked[i - 1][1] <= startTime)) {
    this.booked.splice(i, 0, [startTime, endTime]);
    return true;
  }
  return false;
};

/**
 * Your MyCalendar object will be instantiated and called as such:
 * var obj = new MyCalendar()
 * var param_1 = obj.book(startTime,endTime)
 */
```

# 731. 我的日程安排表 II

```js
var MyCalendarTwo = function () {
  this.booked = [];
  this.overlaps = [];
};

/**
 * @param {number} startTime
 * @param {number} endTime
 * @return {boolean}
 */
MyCalendarTwo.prototype.book = function (startTime, endTime) {
  for (const [l, r] of this.overlaps) {
    if (l < endTime && r > startTime) {
      return false;
    }
  }
  for (const [l, r] of this.booked) {
    if (l < endTime && r > startTime) {
      this.overlaps.push([Math.max(startTime, l), Math.min(endTime, r)]);
    }
  }
  this.booked.push([startTime, endTime]);
  return true;
};

/**
 * Your MyCalendarTwo object will be instantiated and called as such:
 * var obj = new MyCalendarTwo()
 * var param_1 = obj.book(startTime,endTime)
 */
```

# 732. 我的日程安排表 III

```js
var MyCalendarThree = function () {
  this.cnt = {};
};

/**
 * @param {number} startTime
 * @param {number} endTime
 * @return {number}
 */
MyCalendarThree.prototype.book = function (startTime, endTime) {
  this.cnt[startTime] = (this.cnt[startTime] || 0) + 1;
  this.cnt[endTime] = (this.cnt[endTime] || 0) - 1;

  let ans = 0;
  let maxBook = 0;

  for (const value of Object.values(this.cnt)) {
    maxBook += value;
    ans = Math.max(maxBook, ans);
  }

  return ans;
};

/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * var obj = new MyCalendarThree()
 * var param_1 = obj.book(startTime,endTime)
 */
```

# 2241. 设计一个 ATM 机器

```js
const DENOMINATIONS = [20, 50, 100, 200, 500];
const KINDS = DENOMINATIONS.length;

var ATM = function () {
  this.banknotes = new Array(KINDS).fill(0);
};

/**
 * @param {number[]} banknotesCount
 * @return {void}
 */
ATM.prototype.deposit = function (banknotesCount) {
  for (let i = 0; i < KINDS; i++) {
    this.banknotes[i] += banknotesCount[i];
  }
};

/**
 * @param {number} amount
 * @return {number[]}
 */
ATM.prototype.withdraw = function (amount) {
  const ans = new Array(KINDS).fill(0);

  for (let i = KINDS - 1; i >= 0; i--) {
    ans[i] = Math.min(this.banknotes[i], Math.floor(amount / DENOMINATIONS[i]));
    amount -= ans[i] * DENOMINATIONS[i];
  }

  if (amount !== 0) {
    return [-1];
  }

  for (let i = 0; i < KINDS; i++) {
    this.banknotes[i] -= ans[i];
  }

  return ans;
};

/**
 * Your ATM object will be instantiated and called as such:
 * var obj = new ATM()
 * obj.deposit(banknotesCount)
 * var param_2 = obj.withdraw(amount)
 */
```

# 2274. 不含特殊楼层的最大连续楼层数

```js
/**
 * @param {number} bottom
 * @param {number} top
 * @param {number[]} special
 * @return {number}
 */
var maxConsecutive = function (bottom, top, special) {
  special.sort((a, b) => a - b);
  const n = special.length;
  let ans = Math.max(top - special[n - 1], special[0] - bottom);
  for (let i = 1; i < n; i++) {
    ans = Math.max(ans, special[i] - special[i - 1] - 1);
  }
  return ans;
};
```

# 3019. 按键变更的次数

```js
/**
 * @param {string} s
 * @return {number}
 */
var countKeyChanges = function (s) {
  const n = s.length;
  const k = "A".charCodeAt(0) - "a".charCodeAt(0);
  let ans = 0;
  for (let i = 1; i < n; i++) {
    if ((s.charCodeAt(i) - s.charCodeAt(i - 1)) % k) {
      ans++;
    }
  }
  return ans;
};
```

# 2264. 字符串中最大的 3 位相同数字

```js
/**
 * @param {string} num
 * @return {string}
 */
var largestGoodInteger = function (num) {
  const n = num.length;
  let ans = "";
  for (let i = 2; i < n; i++) {
    if (num[i] === num[i - 1] && num[i - 1] === num[i - 2]) {
      const str = num.substring(i - 2, i + 1);
      if (str > ans) {
        ans = str;
      }
    }
  }
  return ans;
};
```

# 3297. 统计重新排列后包含另一个字符串的子字符串数目 I

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var validSubstringCount = function (word1, word2) {
  const path = new Array(26).fill(0);
  for (const s of word2) {
    path[s.charCodeAt(0) - "a".charCodeAt(0)]--;
  }
  const n = word1.length;
  let cnt = path.filter((i) => i < 0).length;
  const update = (c, add) => {
    if (add === 1 && path[c] === -1) {
      cnt--;
    } else if (add === -1 && path[c] === 0) {
      cnt++;
    }
    path[c] += add;
  };
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    update(word1.charCodeAt(right) - "a".charCodeAt(0), 1);
    while (cnt === 0) {
      ans += n - right;
      update(word1.charCodeAt(left) - "a".charCodeAt(0), -1);
      left++;
    }
  }
  return ans;
};
```

# 3298. 统计重新排列后包含另一个字符串的子字符串数目 II

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var validSubstringCount = function (word1, word2) {
  const path = new Array(26).fill(0);
  for (const s of word2) {
    path[s.charCodeAt(0) - "a".charCodeAt(0)]--;
  }
  const n = word1.length;
  let cnt = path.filter((i) => i < 0).length;
  const update = (c, add) => {
    if (add === 1 && path[c] === -1) {
      cnt--;
    } else if (add === -1 && path[c] === 0) {
      cnt++;
    }
    path[c] += add;
  };
  let ans = 0;
  for (let left = 0, right = 0; right < n; right++) {
    update(word1.charCodeAt(right) - "a".charCodeAt(0), 1);
    while (cnt === 0) {
      ans += n - right;
      update(word1.charCodeAt(left) - "a".charCodeAt(0), -1);
      left++;
    }
  }
  return ans;
};
```

# 3270. 求出数字答案

```js
/**
 * @param {number} num1
 * @param {number} num2
 * @param {number} num3
 * @return {number}
 */
var generateKey = function (num1, num2, num3) {
  const getNum = (num) => {
    if (num < 10) {
      return "000" + num;
    }
    if (num < 100) {
      return "00" + num;
    }
    if (num < 1000) {
      return "0" + num;
    }
    return "" + num;
  };
  num1 = getNum(num1);
  num2 = getNum(num2);
  num3 = getNum(num3);
  let ans = "";
  for (let i = 0; i < 4; i++) {
    ans += Math.min(num1[i], num2[i], num3[i]);
  }
  return Number(ans);
};
```

# 2275. 按位与结果大于零的最长组合

```js
/**
 * @param {number[]} candidates
 * @return {number}
 */
var largestCombination = function (candidates) {
  const cnt = new Array(24).fill(0);
  for (let x of candidates) {
    let i = 0;
    while (x) {
      cnt[i] += x & 1;
      x >>= 1;
      i += 1;
    }
  }
  return Math.max(...cnt);
};
```

# 2270. 分割数组的方案数

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var waysToSplitArray = function (nums) {
  let sum = nums.reduce((a, b) => a + b);
  const n = nums.length;
  let temp = 0;
  let ans = 0;
  for (let i = 0; i < n - 1; i++) {
    temp += nums[i];
    sum -= nums[i];
    if (temp >= sum) {
      ans++;
    }
  }
  return ans;
};
```

# 3065. 超过阈值的最少操作数 I

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minOperations = function (nums, k) {
  nums.sort((a, b) => a - b);
  const n = nums.length;
  let left = 0;
  let right = n - 1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (nums[mid] < k) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
};
```